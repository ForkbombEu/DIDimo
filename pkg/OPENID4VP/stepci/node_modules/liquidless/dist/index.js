"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderObject = exports.renderString = void 0;
const flat_1 = __importDefault(require("flat"));
const filters_1 = require("./filters");
const getType = (value) => Array.isArray(value) ? 'array' : value === null ? 'null' : typeof value;
function renderString(template, props, options) {
    const delimiters = options?.delimiters ?? ['{{', '}}'];
    const expressions = template.split(new RegExp(`\\${delimiters[0]}(.+?)${delimiters[1]}`, 'g'));
    const combinedFilters = { ...filters_1.defaultFilters, ...options?.filters };
    for (let i = 1; i < expressions.length; i += 2) {
        const [variable, ...filters] = expressions[i]
            .split('|')
            .map((s) => s.trim());
        const variableValue = props[variable];
        expressions[i] = filters.reduce((variableValue, filter) => {
            const splitPattern = /:(?![^{}]*})/g;
            const [filterMethod, args] = filter.split(splitPattern);
            const parsedArgs = (0, filters_1.parseArgs)(args ?? '');
            return combinedFilters[filterMethod]
                ? combinedFilters[filterMethod](variableValue, parsedArgs, variable)
                : variableValue;
        }, variableValue);
    }
    // if there are no other expressions, return the first one which can be of any type, for example a number
    if (expressions.length === 3 &&
        expressions[0] === '' &&
        expressions[2] === '') {
        return expressions[1];
    }
    return expressions.join('');
}
exports.renderString = renderString;
function renderObject(object, props, options) {
    const flatProps = (0, flat_1.default)(props);
    const transform = (obj) => {
        const transformedNode = new (Object.getPrototypeOf(obj).constructor)();
        for (const [key, value] of Object.entries(obj)) {
            const nodeType = getType(value);
            if (nodeType === 'object' || nodeType === 'array') {
                transformedNode[key] = transform(value);
            }
            else if (nodeType === 'string') {
                transformedNode[key] = renderString(value, flatProps, options);
            }
            else {
                transformedNode[key] = value;
            }
        }
        return transformedNode;
    };
    return transform(object);
}
exports.renderObject = renderObject;
