{
  "version": 3,
  "sources": ["../../src/sustainable-web-design.js"],
  "sourcesContent": ["\"use strict\";\n\n/**\n * Sustainable Web Design\n *\n * Updated calculations and figures from\n * https://sustainablewebdesign.org/calculating-digital-emissions/\n *\n *\n */\nimport debugFactory from \"debug\";\nconst log = debugFactory(\"tgwf:sustainable-web-design\");\n\nimport { fileSize } from \"./constants/index.js\";\nimport { formatNumber } from \"./helpers/index.js\";\n\n// this refers to the estimated total energy use for the internet around 2000 TWh,\n// divided by the total transfer it enables around 2500 exabytes\nconst KWH_PER_GB = 0.81;\n\n// these constants outline how the energy is attributed to\n// different parts of the system in the SWD model\nconst END_USER_DEVICE_ENERGY = 0.52;\nconst NETWORK_ENERGY = 0.14;\nconst DATACENTER_ENERGY = 0.15;\nconst PRODUCTION_ENERGY = 0.19;\n\n// These carbon intensity figures https://ember-climate.org/data/data-explorer\n// - Global carbon intensity for 2021\nconst GLOBAL_INTENSITY = 442;\nconst RENEWABLES_INTENSITY = 50;\n\n// Taken from: https://gitlab.com/wholegrain/carbon-api-2-0/-/blob/master/includes/carbonapi.php\n\nconst FIRST_TIME_VIEWING_PERCENTAGE = 0.75;\nconst RETURNING_VISITOR_PERCENTAGE = 0.25;\nconst PERCENTAGE_OF_DATA_LOADED_ON_SUBSEQUENT_LOAD = 0.02;\n\nclass SustainableWebDesign {\n  constructor(options) {\n    this.options = options;\n  }\n\n  /**\n   * Accept a figure for bytes transferred and return an object representing\n   * the share of the total enrgy use of the entire system, broken down\n   * by each corresponding system component\n   *\n   * @param {number}  bytes - the data transferred in bytes\n   * @return {object} Object containing the energy in kilowatt hours, keyed by system component\n   */\n  energyPerByteByComponent(bytes) {\n    const transferedBytesToGb = bytes / fileSize.GIGABYTE;\n    const energyUsage = transferedBytesToGb * KWH_PER_GB;\n\n    // return the total energy, with breakdown by component\n    return {\n      consumerDeviceEnergy: energyUsage * END_USER_DEVICE_ENERGY,\n      networkEnergy: energyUsage * NETWORK_ENERGY,\n      productionEnergy: energyUsage * PRODUCTION_ENERGY,\n      dataCenterEnergy: energyUsage * DATACENTER_ENERGY,\n    };\n  }\n  /**\n   * Accept an object keys by the different system components, and\n   * return an object with the co2 figures key by the each component\n   *\n   * @param {object} energyBycomponent - energy grouped by the four system components\n   * @param {number} [carbonIntensity] - carbon intensity to apply to the datacentre values\n   * @return {number} the total number in grams of CO2 equivalent emissions\n   */\n  co2byComponent(energyBycomponent, carbonIntensity = GLOBAL_INTENSITY) {\n    const returnCO2ByComponent = {};\n    for (const [key, value] of Object.entries(energyBycomponent)) {\n      // we update the datacentre, as that's what we have information\n      // about.\n      if (key.startsWith(\"dataCenterEnergy\")) {\n        returnCO2ByComponent[key] = value * carbonIntensity;\n      } else {\n        // We don't have info about the device location,\n        // nor the network path used, nor the production emissions\n        // so we revert to global figures\n        returnCO2ByComponent[key] = value * GLOBAL_INTENSITY;\n      }\n    }\n    return returnCO2ByComponent;\n  }\n\n  /**\n   * Accept a figure for bytes transferred and return a single figure for CO2\n   * emissions. Where information exists about the origin data is being\n   * fetched from, a different carbon intensity figure\n   * is applied for the datacentre share of the carbon intensity.\n   *\n   * @param {number} bytes - the data transferred in bytes\n   * @param {number} `carbonIntensity` the carbon intensity for datacentre (average figures, not marginal ones)\n   * @return {number} the total number in grams of CO2 equivalent emissions\n   */\n  perByte(bytes, carbonIntensity = GLOBAL_INTENSITY) {\n    const energyBycomponent = this.energyPerByteByComponent(bytes);\n\n    // when faced with falsy values, fallback to global intensity\n    if (Boolean(carbonIntensity) === false) {\n      carbonIntensity = GLOBAL_INTENSITY;\n    }\n    // if we have a boolean, we have a green result from the green web checker\n    // use the renewables intensity\n    if (carbonIntensity === true) {\n      carbonIntensity = RENEWABLES_INTENSITY;\n    }\n\n    // otherwise when faced with non numeric values throw an error\n    if (typeof carbonIntensity !== \"number\") {\n      throw new Error(\n        `perByte expects a numeric value or boolean for the carbon intensity value. Received: ${carbonIntensity}`\n      );\n    }\n\n    const co2ValuesbyComponent = this.co2byComponent(\n      energyBycomponent,\n      carbonIntensity\n    );\n\n    // pull out our values\u2026\n    const co2Values = Object.values(co2ValuesbyComponent);\n\n    // so we can return their sum\n    return co2Values.reduce(\n      (prevValue, currentValue) => prevValue + currentValue\n    );\n  }\n\n  /**\n   * Accept a figure for bytes transferred and return a single figure for CO2\n   * emissions. This method applies caching assumptions from the original Sustainable Web Design model.\n   *\n   * @param {number} bytes - the data transferred in bytes\n   * @param {number} `carbonIntensity` the carbon intensity for datacentre (average figures, not marginal ones)\n   * @return {number} the total number in grams of CO2 equivalent emissions\n   */\n  perVisit(bytes, carbonIntensity = GLOBAL_INTENSITY) {\n    const energyBycomponent = this.energyPerVisitByComponent(bytes);\n\n    // when faced with falsy values, fallback to global intensity\n    if (Boolean(carbonIntensity) === false) {\n      carbonIntensity = GLOBAL_INTENSITY;\n    }\n    // if we have a boolean, we have a green result from the green web checker\n    // use the renewables intensity\n    if (carbonIntensity === true) {\n      carbonIntensity = RENEWABLES_INTENSITY;\n    }\n\n    // otherwise when faced with non numeric values throw an error\n    if (typeof carbonIntensity !== \"number\") {\n      throw new Error(\n        `perVisit expects a numeric value or boolean for the carbon intensity value. Received: ${carbonIntensity}`\n      );\n    }\n\n    const co2ValuesbyComponent = this.co2byComponent(\n      energyBycomponent,\n      carbonIntensity\n    );\n\n    // pull out our values\u2026\n    const co2Values = Object.values(co2ValuesbyComponent);\n\n    // so we can return their sum\n    return co2Values.reduce(\n      (prevValue, currentValue) => prevValue + currentValue\n    );\n  }\n\n  /**\n   * Accept a figure for bytes transferred and return the number of kilowatt hours used\n   * by the total system for this data transfer\n   *\n   * @param {number} bytes\n   * @return {number} the number of kilowatt hours used\n   */\n  energyPerByte(bytes) {\n    const energyByComponent = this.energyPerByteByComponent(bytes);\n\n    // pull out our values\u2026\n    const energyValues = Object.values(energyByComponent);\n\n    // so we can return their sum\n    return energyValues.reduce(\n      (prevValue, currentValue) => prevValue + currentValue\n    );\n  }\n\n  /**\n   * Accept a figure for bytes transferred, and return an object containing figures\n   * per system component, with the caching assumptions applied. This tries to account\n   * for webpages being loaded from a cache by browsers, so if you had a thousand page views,\n   * and tried to work out the energy per visit, the numbers would reflect the reduced amounts\n   * of transfer.\n   *\n   * @param {number} bytes - the data transferred in bytes for loading a webpage\n   * @param {number} firstView - what percentage of visits are loading this page for the first time\n   * @param {number} returnView - what percentage of visits are loading this page for subsequent times\n   * @param {number} dataReloadRatio - what percentage of a page is reloaded on each subsequent page view\n   *\n   * @return {object} Object containing the energy in kilowatt hours, keyed by system component\n   */\n  energyPerVisitByComponent(\n    bytes,\n    firstView = FIRST_TIME_VIEWING_PERCENTAGE,\n    returnView = RETURNING_VISITOR_PERCENTAGE,\n    dataReloadRatio = PERCENTAGE_OF_DATA_LOADED_ON_SUBSEQUENT_LOAD\n  ) {\n    const energyBycomponent = this.energyPerByteByComponent(bytes);\n    const cacheAdjustedSegmentEnergy = {};\n\n    log({ energyBycomponent });\n    const energyValues = Object.values(energyBycomponent);\n\n    // for this, we want\n    for (const [key, value] of Object.entries(energyBycomponent)) {\n      // represent the first load\n      cacheAdjustedSegmentEnergy[`${key} - first`] = value * firstView;\n\n      // then represent the subsequent load\n      cacheAdjustedSegmentEnergy[`${key} - subsequent`] =\n        value * returnView * dataReloadRatio;\n    }\n    log({ cacheAdjustedSegmentEnergy });\n\n    return cacheAdjustedSegmentEnergy;\n  }\n\n  /**\n   * Accept a figure for bytes, and return the total figure for energy per visit\n   * using the default caching assumptions for loading a single website\n   *\n   * @param {number} bytes\n   * @return {number} the total energy use for the visit, after applying the caching assumptions\n   */\n  energyPerVisit(bytes) {\n    // fetch the values using the default caching assumptions\n    // const energyValues = Object.values(this.energyPerVisitByComponent(bytes));\n\n    let firstVisits = 0;\n    let subsequentVisits = 0;\n\n    const energyBycomponent = Object.entries(\n      this.energyPerVisitByComponent(bytes)\n    );\n\n    for (const [key, val] of energyBycomponent) {\n      if (key.indexOf(\"first\") > 0) {\n        firstVisits += val;\n      }\n    }\n\n    for (const [key, val] of energyBycomponent) {\n      if (key.indexOf(\"subsequent\") > 0) {\n        subsequentVisits += val;\n      }\n    }\n\n    return firstVisits + subsequentVisits;\n  }\n\n  // TODO: this method looks like it applies the carbon intensity\n  // change to the *entire* system, not just the datacenter.\n  emissionsPerVisitInGrams(energyPerVisit, carbonintensity = GLOBAL_INTENSITY) {\n    return formatNumber(energyPerVisit * carbonintensity);\n  }\n\n  annualEnergyInKwh(energyPerVisit, monthlyVisitors = 1000) {\n    return energyPerVisit * monthlyVisitors * 12;\n  }\n\n  annualEmissionsInGrams(co2grams, monthlyVisitors = 1000) {\n    return co2grams * monthlyVisitors * 12;\n  }\n\n  annualSegmentEnergy(annualEnergy) {\n    return {\n      consumerDeviceEnergy: formatNumber(annualEnergy * END_USER_DEVICE_ENERGY),\n      networkEnergy: formatNumber(annualEnergy * NETWORK_ENERGY),\n      dataCenterEnergy: formatNumber(annualEnergy * DATACENTER_ENERGY),\n      productionEnergy: formatNumber(annualEnergy * PRODUCTION_ENERGY),\n    };\n  }\n}\n\nexport { SustainableWebDesign };\nexport default SustainableWebDesign;\n"],
  "mappings": "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",
  "names": []
}
