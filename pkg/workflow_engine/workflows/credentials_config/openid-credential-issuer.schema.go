// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package credentials_config

import "encoding/json"
import "fmt"
import "reflect"

type OpenidCredentialIssuerSchemaJson struct {
	// Array of OAuth 2.0 Authorization Server identifiers.
	AuthorizationServers []string `json:"authorization_servers,omitempty" yaml:"authorization_servers,omitempty" mapstructure:"authorization_servers,omitempty"`

	// BatchCredentialIssuance corresponds to the JSON schema field
	// "batch_credential_issuance".
	BatchCredentialIssuance *OpenidCredentialIssuerSchemaJsonBatchCredentialIssuance `json:"batch_credential_issuance,omitempty" yaml:"batch_credential_issuance,omitempty" mapstructure:"batch_credential_issuance,omitempty"`

	// CredentialConfigurationsSupported corresponds to the JSON schema field
	// "credential_configurations_supported".
	CredentialConfigurationsSupported OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupported `json:"credential_configurations_supported" yaml:"credential_configurations_supported" mapstructure:"credential_configurations_supported"`

	// URL of the Credential Issuer's Credential Endpoint.
	CredentialEndpoint string `json:"credential_endpoint" yaml:"credential_endpoint" mapstructure:"credential_endpoint"`

	// The Credential Issuer's identifier
	CredentialIssuer string `json:"credential_issuer" yaml:"credential_issuer" mapstructure:"credential_issuer"`

	// CredentialResponseEncryption corresponds to the JSON schema field
	// "credential_response_encryption".
	CredentialResponseEncryption *OpenidCredentialIssuerSchemaJsonCredentialResponseEncryption `json:"credential_response_encryption,omitempty" yaml:"credential_response_encryption,omitempty" mapstructure:"credential_response_encryption,omitempty"`

	// URL of the Credential Issuer's Deferred Credential Endpoint.
	DeferredCredentialEndpoint *string `json:"deferred_credential_endpoint,omitempty" yaml:"deferred_credential_endpoint,omitempty" mapstructure:"deferred_credential_endpoint,omitempty"`

	// Display corresponds to the JSON schema field "display".
	Display []OpenidCredentialIssuerSchemaJsonDisplayElem `json:"display,omitempty" yaml:"display,omitempty" mapstructure:"display,omitempty"`

	// URL of the Credential Issuer's Nonce Endpoint.
	NonceEndpoint *string `json:"nonce_endpoint,omitempty" yaml:"nonce_endpoint,omitempty" mapstructure:"nonce_endpoint,omitempty"`

	// URL of the Credential Issuer's Notification Endpoint.
	NotificationEndpoint *string `json:"notification_endpoint,omitempty" yaml:"notification_endpoint,omitempty" mapstructure:"notification_endpoint,omitempty"`

	// JWT containing Credential Issuer metadata parameters as claims.
	SignedMetadata *string `json:"signed_metadata,omitempty" yaml:"signed_metadata,omitempty" mapstructure:"signed_metadata,omitempty"`
}

type OpenidCredentialIssuerSchemaJsonBatchCredentialIssuance struct {
	// BatchSize corresponds to the JSON schema field "batch_size".
	BatchSize int `json:"batch_size" yaml:"batch_size" mapstructure:"batch_size"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJsonBatchCredentialIssuance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["batch_size"]; raw != nil && !ok {
		return fmt.Errorf("field batch_size in OpenidCredentialIssuerSchemaJsonBatchCredentialIssuance: required")
	}
	type Plain OpenidCredentialIssuerSchemaJsonBatchCredentialIssuance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if 1 > plain.BatchSize {
		return fmt.Errorf("field %s: must be >= %v", "batch_size", 1)
	}
	*j = OpenidCredentialIssuerSchemaJsonBatchCredentialIssuance(plain)
	return nil
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupported map[string]struct {
	// CredentialDefinition corresponds to the JSON schema field
	// "credential_definition".
	CredentialDefinition *OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialDefinition `json:"credential_definition,omitempty" yaml:"credential_definition,omitempty" mapstructure:"credential_definition,omitempty"`

	// CredentialSigningAlgValuesSupported corresponds to the JSON schema field
	// "credential_signing_alg_values_supported".
	CredentialSigningAlgValuesSupported []OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem `json:"credential_signing_alg_values_supported,omitempty" yaml:"credential_signing_alg_values_supported,omitempty" mapstructure:"credential_signing_alg_values_supported,omitempty"`

	// CryptographicBindingMethodsSupported corresponds to the JSON schema field
	// "cryptographic_binding_methods_supported".
	CryptographicBindingMethodsSupported []OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem `json:"cryptographic_binding_methods_supported,omitempty" yaml:"cryptographic_binding_methods_supported,omitempty" mapstructure:"cryptographic_binding_methods_supported,omitempty"`

	// Display corresponds to the JSON schema field "display".
	Display []OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueDisplayElem `json:"display,omitempty" yaml:"display,omitempty" mapstructure:"display,omitempty"`

	// Format corresponds to the JSON schema field "format".
	Format string `json:"format" yaml:"format" mapstructure:"format"`

	// ProofTypesSupported corresponds to the JSON schema field
	// "proof_types_supported".
	ProofTypesSupported OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupported `json:"proof_types_supported,omitempty" yaml:"proof_types_supported,omitempty" mapstructure:"proof_types_supported,omitempty"`

	// Scope corresponds to the JSON schema field "scope".
	Scope *string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialDefinition struct {
	// CredentialSubject corresponds to the JSON schema field "credentialSubject".
	CredentialSubject OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialDefinitionCredentialSubject `json:"credentialSubject,omitempty" yaml:"credentialSubject,omitempty" mapstructure:"credentialSubject,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type []string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialDefinitionCredentialSubject map[string]struct {
	// Display corresponds to the JSON schema field "display".
	Display []OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialDefinitionCredentialSubjectValueDisplayElem `json:"display,omitempty" yaml:"display,omitempty" mapstructure:"display,omitempty"`

	// Mandatory corresponds to the JSON schema field "mandatory".
	Mandatory *bool `json:"mandatory,omitempty" yaml:"mandatory,omitempty" mapstructure:"mandatory,omitempty"`
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialDefinitionCredentialSubjectValueDisplayElem struct {
	// Locale corresponds to the JSON schema field "locale".
	Locale *string `json:"locale,omitempty" yaml:"locale,omitempty" mapstructure:"locale,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialDefinitionCredentialSubjectValueDisplayElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialDefinitionCredentialSubjectValueDisplayElem: required")
	}
	type Plain OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialDefinitionCredentialSubjectValueDisplayElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialDefinitionCredentialSubjectValueDisplayElem(plain)
	return nil
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem string

const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElemES256 OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem = "ES256"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElemES256K OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem = "ES256K"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElemEdDSA OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem = "EdDSA"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElemRS256 OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem = "RS256"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElemRSA OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem = "RSA"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElemRsaSignature2018 OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem = "RsaSignature2018"

var enumValues_OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem = []interface{}{
	"ES256",
	"EdDSA",
	"RS256",
	"ES256K",
	"RSA",
	"RsaSignature2018",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem, v)
	}
	*j = OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCredentialSigningAlgValuesSupportedElem(v)
	return nil
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem string

const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElemCoseKey OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = "cose_key"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElemDid OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = "did"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElemDidDyne OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = "did:dyne"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElemDidDyneSandboxSignroom OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = "did:dyne:sandbox.signroom"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElemDidEbsi OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = "did:ebsi"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElemDidJwk OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = "did:jwk"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElemDidKey OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = "did:key"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElemDidWeb OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = "did:web"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElemJWK OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = "JWK"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElemJwk OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = "jwk"

var enumValues_OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem = []interface{}{
	"JWK",
	"jwk",
	"did",
	"did:web",
	"did:ebsi",
	"did:jwk",
	"did:dyne",
	"did:dyne:sandbox.signroom",
	"did:key",
	"cose_key",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem, v)
	}
	*j = OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueCryptographicBindingMethodsSupportedElem(v)
	return nil
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueDisplayElem struct {
	// Locale corresponds to the JSON schema field "locale".
	Locale *string `json:"locale,omitempty" yaml:"locale,omitempty" mapstructure:"locale,omitempty"`

	// Logo corresponds to the JSON schema field "logo".
	Logo *OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueDisplayElemLogo `json:"logo,omitempty" yaml:"logo,omitempty" mapstructure:"logo,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueDisplayElemLogo struct {
	// AltText corresponds to the JSON schema field "alt_text".
	AltText *string `json:"alt_text,omitempty" yaml:"alt_text,omitempty" mapstructure:"alt_text,omitempty"`

	// Uri corresponds to the JSON schema field "uri".
	Uri *string `json:"uri,omitempty" yaml:"uri,omitempty" mapstructure:"uri,omitempty"`

	// Url corresponds to the JSON schema field "url".
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueDisplayElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueDisplayElem: required")
	}
	type Plain OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueDisplayElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueDisplayElem(plain)
	return nil
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupported map[string]struct {
	// KeyAttestationsRequired corresponds to the JSON schema field
	// "key_attestations_required".
	KeyAttestationsRequired *OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueKeyAttestationsRequired `json:"key_attestations_required,omitempty" yaml:"key_attestations_required,omitempty" mapstructure:"key_attestations_required,omitempty"`

	// ProofSigningAlgValuesSupported corresponds to the JSON schema field
	// "proof_signing_alg_values_supported".
	ProofSigningAlgValuesSupported []OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem `json:"proof_signing_alg_values_supported" yaml:"proof_signing_alg_values_supported" mapstructure:"proof_signing_alg_values_supported"`
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueKeyAttestationsRequired struct {
	// KeyStorage corresponds to the JSON schema field "key_storage".
	KeyStorage []string `json:"key_storage,omitempty" yaml:"key_storage,omitempty" mapstructure:"key_storage,omitempty"`

	// UserAuthentication corresponds to the JSON schema field "user_authentication".
	UserAuthentication []string `json:"user_authentication,omitempty" yaml:"user_authentication,omitempty" mapstructure:"user_authentication,omitempty"`
}

type OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem string

const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElemES256 OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem = "ES256"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElemEdDSA OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem = "EdDSA"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElemPS256 OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem = "PS256"
const OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElemRS256 OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem = "RS256"

var enumValues_OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem = []interface{}{
	"ES256",
	"EdDSA",
	"PS256",
	"RS256",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem, v)
	}
	*j = OpenidCredentialIssuerSchemaJsonCredentialConfigurationsSupportedValueProofTypesSupportedValueProofSigningAlgValuesSupportedElem(v)
	return nil
}

type OpenidCredentialIssuerSchemaJsonCredentialResponseEncryption struct {
	// AlgValuesSupported corresponds to the JSON schema field "alg_values_supported".
	AlgValuesSupported []OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElem `json:"alg_values_supported" yaml:"alg_values_supported" mapstructure:"alg_values_supported"`

	// EncValuesSupported corresponds to the JSON schema field "enc_values_supported".
	EncValuesSupported []OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElem `json:"enc_values_supported" yaml:"enc_values_supported" mapstructure:"enc_values_supported"`

	// EncryptionRequired corresponds to the JSON schema field "encryption_required".
	EncryptionRequired bool `json:"encryption_required" yaml:"encryption_required" mapstructure:"encryption_required"`
}

type OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElem string

const OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElemES256 OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElem = "ES256"
const OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElemEdDSA OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElem = "EdDSA"
const OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElemRS256 OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElem = "RS256"

var enumValues_OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElem = []interface{}{
	"ES256",
	"EdDSA",
	"RS256",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElem, v)
	}
	*j = OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionAlgValuesSupportedElem(v)
	return nil
}

type OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElem string

const OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElemA128CBCHS256 OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElem = "A128CBC-HS256"
const OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElemA128GCM OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElem = "A128GCM"

var enumValues_OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElem = []interface{}{
	"A128CBC-HS256",
	"A128GCM",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElem, v)
	}
	*j = OpenidCredentialIssuerSchemaJsonCredentialResponseEncryptionEncValuesSupportedElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJsonCredentialResponseEncryption) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["alg_values_supported"]; raw != nil && !ok {
		return fmt.Errorf("field alg_values_supported in OpenidCredentialIssuerSchemaJsonCredentialResponseEncryption: required")
	}
	if _, ok := raw["enc_values_supported"]; raw != nil && !ok {
		return fmt.Errorf("field enc_values_supported in OpenidCredentialIssuerSchemaJsonCredentialResponseEncryption: required")
	}
	if _, ok := raw["encryption_required"]; raw != nil && !ok {
		return fmt.Errorf("field encryption_required in OpenidCredentialIssuerSchemaJsonCredentialResponseEncryption: required")
	}
	type Plain OpenidCredentialIssuerSchemaJsonCredentialResponseEncryption
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OpenidCredentialIssuerSchemaJsonCredentialResponseEncryption(plain)
	return nil
}

type OpenidCredentialIssuerSchemaJsonDisplayElem struct {
	// Locale corresponds to the JSON schema field "locale".
	Locale *string `json:"locale,omitempty" yaml:"locale,omitempty" mapstructure:"locale,omitempty"`

	// Logo corresponds to the JSON schema field "logo".
	Logo *OpenidCredentialIssuerSchemaJsonDisplayElemLogo `json:"logo,omitempty" yaml:"logo,omitempty" mapstructure:"logo,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

type OpenidCredentialIssuerSchemaJsonDisplayElemLogo struct {
	// AltText corresponds to the JSON schema field "alt_text".
	AltText *string `json:"alt_text,omitempty" yaml:"alt_text,omitempty" mapstructure:"alt_text,omitempty"`

	// Uri corresponds to the JSON schema field "uri".
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJsonDisplayElemLogo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in OpenidCredentialIssuerSchemaJsonDisplayElemLogo: required")
	}
	type Plain OpenidCredentialIssuerSchemaJsonDisplayElemLogo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OpenidCredentialIssuerSchemaJsonDisplayElemLogo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OpenidCredentialIssuerSchemaJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["credential_configurations_supported"]; raw != nil && !ok {
		return fmt.Errorf("field credential_configurations_supported in OpenidCredentialIssuerSchemaJson: required")
	}
	if _, ok := raw["credential_endpoint"]; raw != nil && !ok {
		return fmt.Errorf("field credential_endpoint in OpenidCredentialIssuerSchemaJson: required")
	}
	if _, ok := raw["credential_issuer"]; raw != nil && !ok {
		return fmt.Errorf("field credential_issuer in OpenidCredentialIssuerSchemaJson: required")
	}
	type Plain OpenidCredentialIssuerSchemaJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OpenidCredentialIssuerSchemaJson(plain)
	return nil
}
